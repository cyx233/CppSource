# Jump解题报告

- ## 数据结构

  本体应用了单调队列的数据结构

  #### 单调队列

  ​	单调队列是滑动窗口$O(1)$取出最值的数据结构, 在本题中采用单调递增队列, 使队头为最小值. 对于滑动窗口, 维护一个单调队列 $list$

  滑动窗口入队操作为:

  1. 新入队的数与单调队列 $list$ 队尾进行比较
  2. 若新入队的不大于队尾, 使队尾的数出队, 转1
  3. 若新入队的数大于队尾, 则入队成为单调队列 $list$ 队尾

  出队操作为:

  1. 若出队的数位于单调队列 $list$ 队头, 则单调队列 $list$ 队头出队
  2. 若出队的数不为单调队列 $list$ 队头, 则单调队列不变化

  此种方法能保证队头一定为区间最小值

  

- ## 算法

  分析本题的条件, 不难得出:

  1. 每个点的前继一定是连续的, 即每个点有一个前继区间
  2. 随着点编号的增加, 前继区间的左边界与右边界一定都单调递增的(非严格递增)

  由此, 可以得出算法:

  1. 取后一个点, 计算前继区间, 由分析可知, 单调向后滑动

  2. 若前继区间为空, 说明这个点无法访问. 将其最优时间置为最大值, 同时窗口不滑动

  3. 若前继区间不为空, 则使窗口滑动, 同时维护单调队列. 维护完成后取出前继区间最小值, 更新此点的最优时间(动态规划)

  4. 若没有到最后一个点, 转1, 否则输出最后一点的最优时间

     

- ## 遇到的困难

  单调队列用指针实现比较繁琐, 而且容易空指针导致RE

  #### 解决方法

  ​	使用数组模拟的方式, 用两个整型数据记录队列头与队列尾. 本题中只需要 n 长度的数组就能模拟单调队列.

  

- ## 复杂度估算

  - #### 时间复杂度

    - 读入数据复杂度为$O(n)$
    - 动态规划中, 由于滑动窗口只能向后滑动, 每个点至多进队一次, 出队一次. 对于单调队列情况相同. 所以动态规划复杂度为$O(n)$
    - 单调队列查询最小值复杂度为$O(n)$

    所以总时间复杂度为$O(n)$

  - #### 空间复杂度

    - 存储每个点的信息, 空间为 3*n
    - 单调队列, 空间最大为 n

    所以总空间复杂度为$O(n)$

