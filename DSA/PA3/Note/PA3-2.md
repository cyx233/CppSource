# Hacker

### 数据结构

本题很明显，使用hash表的数据结构

### 构思

将8位六进制数转化为一个unsigned int，通过hash函数映射到hash表。

考虑使用独立链的结构

由题意，不同的字符串可能有相同的六进制密文，所以在hash表中需要同时存储原字符串与密文。便于判断Duplicate。

### 原理

- **hash表的结构**

  每个节点为一个向量，向量中存储结构体Node。Node有两个成员，存储原字符串的value（无符号整型）与存储对应密文的key（字符串数组）

- **hash表的插入**

  插入发生在已知字符串，加入密码本的行为中

  将字符串通过正确的加盐方式加密，获得一个8位16进制密文

  将密文转化为一个unsigned int，使用hash函数获得表中下标。

  遍历此下标中所有的冲突。如果密文相同，进一步判断字符串是否相同。

  若密文与字符串都相同，则将存储的字符串改为”Duplicate“。根据题意”Duplicate“不可能作为密码出现，所以无需担心别的问题。

- **hash表的查询**

  hash表的查询发生在已知密文，查询字符串的行为中。

  将此密文通过hash函数获得hash值，即为hash表中的下标

  遍历此下标中存储的Node，若不存在此密文，输出No

  若存在此密文，输出对应的字符串。

  可以发现，”Duplicate”长度为9，而密文长度不超过8，所以很方便能够判断本次查询是否获得密码。

  如果没有获得密码（No或Duplicate），返回空字符串，

  如果获得了密码，返回密码的首个字符，为了加入“弱口令”需要这个信息。

- **算法**
  1. 首先穷举所有不超过5的合法密码，正确加密后插入hash表。
  2. 读取输入，直接调用查询函数
  3. 若查询函数返回的不是空字符串，则将新增的弱口令插入hash表。

### 实现要点

1. Vector的正确实现
2. hash函数的正确实现
3. 正确的加密，应用crc32流式函数的性质能够更方便地实现正确的加密

### 遇到的困难

第一次实现时时间比较慢，最坏情况2.7秒。

检查代码时发现，1-5位长度的弱口令不需要重复插入密码本，因为已经在初始化时穷举。只需插入新增的6-8位弱口令

改进后时间大大缩短。

### 复杂度估计

- 空间复杂度

  - 所有的密文不超过$18^5+3n$个

  总空间复杂度为$O(n)$

- 时间复杂度

  - 初始化为插入18^5^个密文
  - 查询为$O(1)$操作，共n次
  - 插入弱口令为$O(1)$操作，共3n次

  总时间复杂度为$O(n)$