# kth

### 数据结构

本题选取第k小值的要求，很显然使用堆的数据结构

### 构思

首先，确定不能通过穷举$k^3$个选项获得答案，所以第一步一定是对三个数组分别排序（升序）

考虑一个三维空间$(x,y,z)\ \ x,y,z\in[1,n]$，表示选取第1个数组的第x个数，第2个数组的第y个数，第3个数组的第z个数。

可见，这个空间如果对$x,y,z$三个方向均为递增

根据节点之间的递增关系，可以通过节点进堆、出堆找到第1小，第2小，……，第k小的节点，即得答案

### 原理

- **排序**

  排序可以使用$qsort$函数，只需要重写比较函数即可

- **入堆与出堆的规则**

  很明显，$(1,1,1)$是最小的点，首先入堆，作为初始化

  规定：

  1. 每次取出堆顶节点，自此节点沿$x,y,z$轴向外扩展一格（最多扩展3个节点），向外扩展的一定略大于堆顶元素，若堆顶节点为第i小，向外扩展后，新的堆顶即为第i+1小。需要注意的是，扩展时经过的节点，如果已经在堆中，则不必重复入堆

  2. 去重规则的制定

     考虑二维平面的去重：

     - 若节点为$(1,y)$，则能够向$(1,y+1)$扩展

     - 其他的$(x,y)$，只能向$(x+1,y)$扩展

     发现，如果当前节点为$(a,b),a>1$，说明$(1,b)$先于当前节点进堆，且已经出堆。那么$(1,b+1)$一定已经进堆，那么$(a,b+1)$要么沿着$x=a$被加入过，要么小于$(a,c),c<b+1$。所以$(a,b+1)$此刻不需要进堆。

     这样的规则下，能够遍历所有节点且不会造成重复，同时保证了每次堆顶的节点，一定是剩余所有节点中的最小节点，若有前i个出堆的节点，堆顶即为第i+1小的节点。

     在本题三维空间中，加入规则：

     - 所有节点$(a,b,c)$能够向$(a,b,c+1)$扩展

     - 若节点$z=1，继续执行二维平面规则$

     此规则具有同样的去重作用

  3. 重复操作步骤1，k-1次之后，堆顶即为第k小元素。

### 实现要点

正确的实现小顶堆

正确的实现扩展规则

### 遇到的困难

刚开始使用hash表进行去重，时间大约需要2.7秒，而后改进为现在的方法，时间1.3秒。

第一版由于堆使用了$3k$大小的空间，发生$MLE$（由于第一版还是hash表去重法）

第二版改正为$2k+1$大小，这是因为每次移除一个，最多加入三个，净加入两个，考虑初始化的$(1,1,1)$，操作$k$次总数不超过$2k+1$

### 复杂度估计

- 空间复杂度

  - 堆需要$k$的空间
  - 三个数组需要3n的空间

  总空间复杂度为$O(n+k)$

- 时间复杂度

  - 三个数组排序需要$3nlogn$的时间

  - 最坏情况下，每次先出堆一个，在入堆3个

    第n步（n>1）操作时，初始堆$size=2n-1$，先出堆，后入堆

    $T(n)=log(2n-1)+log(2n-2)+log(2n-1)+log(2n)$

    初始化$t(0)=1,t(1)=4$

    所以总时间为
    $$
    T(k-1)=\Sigma_{i=0}^{k-1}t(i)=5+2log(2(k-1)!)-log2-log(2(k-1))\\=O(klogk)
    $$

  总时间复杂度为$O(nlogn+klogk)$

