# Prefix

### 数据结构

本题没有特殊的数据结构

### 构思

本题目标与字符串前缀有关，很自然的想到了使用KMP算法

KMP算法的next数组指出了重复前缀的位置，能够直接用于本题的计数

### 原理

kmp算法能够$O(n)$时间计算得到$next$数组，

- kmp算法

  初始化：$next[0]=-1$

  规则：读入第$i$个新字符，比较新字符$s[i]$与$s[next[i]]$，若相同，表示$[0, s[next[i]]]$

  为$[0,i]$的最长匹配前缀，$next[i+1] = next[next[i]]+1$

  若不同，则继续寻找$s[next[next[i]]]$， 直到找到匹配前缀，或者确定没有匹配前缀。

对于第$j$个字符，$[0, next[j])$是能匹配$[0, j]$的后缀的最长前缀

根据题意，可以通过$next$数组进行动态规划

- 动态规划规则与原理

  原字符串为$s[n]$，kmp算法得到的数组为$next[n+1]$，动态规划的数组为$dp[n+1]$

  规则为：
  $$
  dp[i] = dp[next[i]]+1
  $$
  原理是：0

  如果每次查找前缀都在前缀末尾做记号，$dp[i]$表示第$i-1$个字符上做记号的数量

  那么$dp[next[i]]$即使最长匹配前缀位置做的记号个数。

  由于是匹配前缀，所以每次匹配前缀做记号，在$i$处一定也能匹配并做记号，同时，前缀$[0,next[i]）$是最长匹配前缀，会被匹配，所以总次数由此加1。

  答案即为所有位置记号总和。即$\Sigma_{i=1}^ndp[i]$

### 实现要点

正确实现kmp算法

### 遇到的困难

第一版上交时，出现了WA错误。

检查代码发现，答案$\Sigma_{i=1}^ndp[i]$可能非常大，求和结果需要使用$long\ long\ int$保存

改正后程序正常运行

### 复杂度估计

- 空间复杂度

  - $next$数组使用$n$的空间
  - $dp$数组使用$n$的空间
  - $s$数组使用$n$的空间

  总空间复杂度为$O(n)$

-  时间复杂度

  - 计算$next$数组使用$O(n)$时间
  - 计算$dp$数组使用$O(n)$时间
  - 计算总和为$O(n)$时间

  总时间为$O(n)$时间