## Graph

### 数据结构

很明显，本题应该应用图的相关知识

我采用了保存邻点的方式（邻接表）

### 构思

应用tarjan算法求出割点和双联通分量

双联通分量使用$Vector$存储包含的节点

很明显，双联通分量之间通过割点连接，将双联通分量与割点视为节点，缩点构建新的图

对于每次询问，只需要找到起点对应的新节点，然后进行深搜找到终点对应的新节点

回溯深搜路径，位于路径上的所有割点以及起点与终点为必经点

### 原理

$tarjan$算法及其原理：

- 标记割点

  使用两个数组记录，$dfn[N]$和$low[N]$ 

  以某个点为根进行深搜，首次访问$u$节点记录$dfn[u]$为深搜顺序。

  遍历$u$的邻点，若邻点$v$，则递归访问$v$，然后$low[u]=min(dfn[v],low[u])$

  如果$u$的邻点$v$已经被访问过，则直接更新$low[u]$

  $low[v]$的意义是，$v$节点不通过$u$节点能够直接联通到的最小$dfn$

  若存在$low[v]>=dfn[u]$，说明若$u$节点移除，$v$节点将与$u$的祖先不再联通。说明$u$是一个割点。

  在这里需要特判根节点，因为根节点没有祖先。如果根节点递归访问了两个及以上孩子，说明根节点是割点。

- 标记双联通分量

  每次递归时首先让$u$入栈

  如果递归从$v$返回至$u$时，判断$u$是割点，说明$root-v$的路径被$u$所割，那么持续退栈，直到出栈元素为$v$ 停止，这些点加上割点$u$ 即为一个双联通分量。

### 实现要点

​	正确的实现$tarjan$算法

###　遇到的困难

​	此算法具体实现细节非常多。其中最麻烦的是记录双联通分量、割点与新图中节点的对应关系。

​	发现，$双联通分量数目+割点数目<=2N－２$，所以只需要数组$new\_id[2N]$，$[0,N]$记录对应双联通分量下标，$[N+1, 2N]$记录对应割点下标即可。

###　复杂度估计

- 时间复杂度：
  - $tarjan$算法中每个点仅访问一次，所以复杂度为$O(n)$。
  - 建树要遍历所有双联通分量，再遍历包含的所有点，仅有割点会被重复访问，复杂度为$O(n)$
  - 由于新图最多$2N-2$个点，深搜复杂度$O(n)$，进行$q$ 次
  - 所以总复杂度为$O(n)+O(n)+qO(n)=qO(n)$
- 空间复杂度
  - 记录原图空间为$O(m)$
  - $tarjan$所需空间$O(n)$
  - 由于原理为缩点，新图空间也是$O(m)$
  - 总复杂度为$O(m)+O(n)+O(m)=O(n+m)$



