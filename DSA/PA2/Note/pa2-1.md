# Build

### 数据结构

很明显，本题的基础数据结构为树。

在树的实现方面，我采用了记录父节点和所有子节点$id$的多叉树结构。

### 构思

每个节点记录本节点的$size$与$height$。利用list存储子节点的$id$

很明显，子节点变动时可以$O(1)$的更新$size$。

同时使用$Queap$的数据结构，辅助记录子节点后缀的最大高度。

当第r个子节点发生变动时，仅通过$O(r)$时间即可完成对$Queap$的维护，进而完成对本节点高度的更新

### 原理

根据题意，保证每次操作的链表访问代价 $cost<10^{-5}$ 

而$Queap$维护的总代价为$cost$，所以使用$Queap$相比于遍历所有孩子的方法有很大的优化

易知, 另外的所有操作（寻址、插入、删除、更新size）总代价均小于等于cost

### 实现要点

所有的操作必须按照链表代价进行。

###　遇到的困难

- $MLE$

  很自然的，第一版程序我使用了课件上的$List$ 模板类，将子节点与$Queap$使用双向链表存储。但是很不幸，完成了debug之后，前十个点就会有$MLE$ 的情况出现，完全不能承受大数据。

  发现主要空间占用在于每个$ListNode$有三个指针，在64位系统下，每有一个子节点，使用三个指针就占用24字节，明显会导致$MLE$。

  ##### 解决方法：

  完全推倒重来，使用课件上的$Vector$代替$List$。而$Vector$每一个元素仅仅是一个$int$，占用4字节。相较$List$空间 优化非常明显。
  
  但是$Vector$的代价与$List$相反，所以如果要控制代价仍然为$cost$的倍数，需要将元素倒序存放，以$Vector$的末尾作为第一个元素，下标关系为 $new\_rank = size()-1-old\_rank$。

- $Segmentation\ Fault$

  在提交九成测之后，在第12,13,14点出现ERROR(6)，最终定位bug为递归深度太大导致的$Segmentation\ Fault$。不仅在初始化树的时候使用递归，而且更新$height$、$size$的时候同样使用了递归。而在极端情况，比如长链，递归深度达到$10^{6}$导致溢出。

  ##### 解决方法：

  初始化时，只需要保证子节点先被访问即可，所以只需要层次遍历入栈，然后出栈更新，就能完成初始化。

  $height$、$size$的递归比较容易修改，很方便能用循环替代，只要返回值表示“是否需要继续向上”即可。

###　复杂度估计

- 时间复杂度：
  - 建树的复杂度为$O(n)$
  - 由上文分析可得，每步操作的代价被$cost$限制，共m步，时间复杂度为$O(mn)$，亦可表示为$O(mcost)$。
  - 所以总复杂度为$O(mcost+n)$
- 空间复杂度
  - 每个节点都自己出现一次，在父节点的子节点数组中出现一次，在$Queap$ 中占用一个位置。所以空间复杂度为O(n)

