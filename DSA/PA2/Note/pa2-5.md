## Temperature

### 数据结构

本题要求查询二维区间最值，所以使用$kdTree$的数据结构

### 构思

每个节点存储：

横坐标，纵坐标，气温

子树区间（由横坐标区间，纵坐标区间共四个数描述）

子树气温最大值、最小值

左孩子下标、右孩子下标

### 原理

- 建树

  根节点代表的区域包含的节点为$[1,n]$。

  先以$x$值排序，取中位数作为根节点，然后二分递归，并以$y$排序（每次递归更换排序的值）

  左孩子包含节点$[1, mid-1]$，右孩子包含节点$[mid+1,n]$

  递归基为区间长度为1。

  然后向上返回下标，父节点记录左右孩子下标，并根据左右孩子信息更新区间范围，温度极值。

  可以发现，子节点表示的区间一定被父节点完全覆盖。所以父节点存储的区间信息可以代表子树所有点。

  

- 查询

  每次查询时，从根节点开始

  1. 判断当前节点代表区间是否被查询完全覆盖，如果完全覆盖，用区间信息更新当前答案并返回。
  2. 判断当前节点代表区间是否与查询有重叠，如果没有，直接返回。
  3. 判断当前节点是否在查询内，如果在，用节点信息更新当前答案$ans$但不返回
  4. 如果有左、右孩子，递归左、右孩子。



### 实现要点

- 高效的判断相交的算法：

  判断高维相交，可以转换为判断多个低维的相交，代码实现更加清晰而且效率更高。

- 剪枝

  递归前判断当前答案与子节点代表区间的最值，如果当前答案已经更优，就可以直接返回

  在递归左、右孩子时，先判断左、右孩子代表的区间最值，优先进入更优的子节点，这样更有可能将另一边剪枝

###　遇到的困难

- $TLE$

  第一版完成后，7~10点均发生$TLE$

  解决方法：

  加入实现要点中提到的剪枝算法。

###　复杂度估计

- 时间复杂度：
  - 建树每个点访问一次，复杂度为$O(n)$
  - 排序时间$T(n)=2T(\frac{n}{2})+O(nlogn)$，根据主定理，$T(n)=O(nlog^2n)$
  - 查询$T(n) = 2T(\frac{n}{4})+2$，根据主定理，$T(n)=O(\sqrt{n})$，共m次
  - 所以总时间为$O(n) + O(nlog^2n)+O(m\sqrt{n})=O(nlog^2n+m\sqrt{n})$
- 空间复杂度
  - 每个节点记录一次，空间复杂度为$O(n)$



